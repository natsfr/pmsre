/***************************************
* Auto generated by BFGen, do not edit *
***************************************/

/*
   bfgen -o cdefs -I pmsre.bfgen -O pmsre_regs.h
*/

#ifndef _PMSRE_BFGEN_DEFS_
#define _PMSRE_BFGEN_DEFS_

/** This register holds the motor position value. @multiple */
#define PMSRE_POS_ADDR(ridx)                         (0x00000000 + (ridx) * 4)
#define PMSRE_POS_COUNT                              8
/** Fractionnal part of the motor position. @multiple */
  #define PMSRE_POS_FRAC(v)                        ((v) << 0)
  #define PMSRE_POS_FRAC_SET(x, v)                 do { (x) = (((x) & ~0x7fffff) | ((v) << 0)); } while(0)
  #define PMSRE_POS_FRAC_GET(x)                    (((x) >> 0) & 0x7fffff)
/** Position bit used to drive the motor step signal. @multiple */
  #define PMSRE_POS_STEP                           0x00800000

/** This defines the value which will be added to the motor posision during each
   cycle of the command. The value is actually pushed into the command fifo when
   the len register is written. @multiple */
#define PMSRE_INC_ADDR(ridx)                         (0x00000020 + (ridx) * 4)
#define PMSRE_INC_COUNT                              8
/** Increment value in Q1.23 format, should not be greater than 1.0 (0x800000).
   This defines the motor speed during the command. @multiple */
  #define PMSRE_INC_FRAC(v)                        ((v) << 0)
  #define PMSRE_INC_FRAC_SET(x, v)                 do { (x) = (((x) & ~0xffffff) | ((v) << 0)); } while(0)
  #define PMSRE_INC_FRAC_GET(x)                    (((x) >> 0) & 0xffffff)
/** Increment sign bit, defines the motor direction during the next command.
   @multiple */
  #define PMSRE_INC_SIGN                           0x01000000

/** Writting to this register schedules a command with the specified duration and
   user id. The increment values of all motors along with the duration and the
   user id are pushed into the scheduled commands fifo. The command will execute
   as soon as all previous commands are completed. Execution will be postponed if
   the fifo of completed commands is full. Both fifos are 4 entries deep.
   @multiple */
#define PMSRE_PUSH_ADDR                              0x00000040
/** Command duration in number of cycles. @multiple */
  #define PMSRE_PUSH_CYCLES(v)                     ((v) << 0)
  #define PMSRE_PUSH_CYCLES_SET(x, v)              do { (x) = (((x) & ~0xffffff) | ((v) << 0)); } while(0)
  #define PMSRE_PUSH_CYCLES_GET(x)                 (((x) >> 0) & 0xffffff)
/** This user defined command id will later be reported in the completed commands
   fifo. @multiple */
  #define PMSRE_PUSH_ID(v)                         ((v) << 24)
  #define PMSRE_PUSH_ID_SET(x, v)                  do { (x) = (((x) & ~0xf000000) | ((v) << 24)); } while(0)
  #define PMSRE_PUSH_ID_GET(x)                     (((x) >> 24) & 0xf)

/** This reports the state, user id and remaining cycles of the running command.
   @multiple */
#define PMSRE_CUR_ADDR                               0x00000060
/** Remaining cycles. @multiple */
  #define PMSRE_CUR_CYCLES(v)                      ((v) << 0)
  #define PMSRE_CUR_CYCLES_SET(x, v)               do { (x) = (((x) & ~0xffffff) | ((v) << 0)); } while(0)
  #define PMSRE_CUR_CYCLES_GET(x)                  (((x) >> 0) & 0xffffff)
/** User defined command id. @multiple */
  #define PMSRE_CUR_ID(v)                          ((v) << 24)
  #define PMSRE_CUR_ID_SET(x, v)                   do { (x) = (((x) & ~0xf000000) | ((v) << 24)); } while(0)
  #define PMSRE_CUR_ID_GET(x)                      (((x) >> 24) & 0xf)
/** Motor driving status. @multiple */
  #define PMSRE_CUR_STATE(v)                       ((PMSRE_CUR_STATE_##v) << 28)
  #define PMSRE_CUR_STATE_SET(x, v)                do { (x) = (((x) & ~0x30000000) | ((PMSRE_CUR_STATE_##v) << 28)); } while(0)
  #define PMSRE_CUR_STATE_GET(x)                   (((x) >> 28) & 0x3)
    #define PMSRE_CUR_STATE_IDLE                     0x00000000
    #define PMSRE_CUR_STATE_RUNNING                  0x00000001
    #define PMSRE_CUR_STATE_DONE                     0x00000002

/** This pops a command status from the fifo of completed commands. Up to 4
   status can be queued in the fifo. @multiple */
#define PMSRE_POP_ADDR                               0x00000080
/** Number of remaining cycles when the command ended. @multiple */
  #define PMSRE_POP_REM(v)                         ((v) << 0)
  #define PMSRE_POP_REM_SET(x, v)                  do { (x) = (((x) & ~0xffffff) | ((v) << 0)); } while(0)
  #define PMSRE_POP_REM_GET(x)                     (((x) >> 0) & 0xffffff)
/** The user defined id of the completed command. @multiple */
  #define PMSRE_POP_ID(v)                          ((v) << 24)
  #define PMSRE_POP_ID_SET(x, v)                   do { (x) = (((x) & ~0xf000000) | ((v) << 24)); } while(0)
  #define PMSRE_POP_ID_GET(x)                      (((x) >> 24) & 0xf)
/** This indicates that the command has been flushed due to a fault or stop
   condition. Any new command will be flushed until the fifo of completed
   commands becomes empty. @multiple */
  #define PMSRE_POP_FLUSH                          0x10000000
/** This indicates that the fifo was not empty (other fields are valid).
   @multiple */
  #define PMSRE_POP_VALID                          0x80000000

/** This reports various device status information. A motor fault on an enabled
   motor will flush all commands. @multiple */
#define PMSRE_STAT_ADDR                              0x000000a0
/** A motor fault condition is currently reported by the motor driver. @multiple
   */
  #define PMSRE_STAT_FAULT_COUNT                   8
  #define PMSRE_STAT_FAULT(fidx)                   (0x00000001 << ((fidx)))
/** End-stop condition detected, preventing motor position increase if watched.
   @multiple */
  #define PMSRE_STAT_ISTOP_COUNT                   8
  #define PMSRE_STAT_ISTOP(fidx)                   (0x00000100 << ((fidx)))
/** End-stop condition detected, preventing motor position decrease if watched.
   @multiple */
  #define PMSRE_STAT_DSTOP_COUNT                   8
  #define PMSRE_STAT_DSTOP(fidx)                   (0x00010000 << ((fidx)))
/** Completed commands fifo is empty. @multiple */
  #define PMSRE_STAT_DEMPTY                        0x01000000
/** Scheduled commands fifo is empty. @multiple */
  #define PMSRE_STAT_SEMPTY                        0x02000000
/** Number of implemented motors minus one. @multiple */
  #define PMSRE_STAT_MCOUNT(v)                     ((v) << 29)
  #define PMSRE_STAT_MCOUNT_SET(x, v)              do { (x) = (((x) & ~0xe0000000) | ((v) << 29)); } while(0)
  #define PMSRE_STAT_MCOUNT_GET(x)                 (((x) >> 29) & 0x7)

/** Enable motor drivers and end-stop inputs watching. Each motor has 2
   associated end-stop, one for each direction. Watched end-stops will make any
   move in the wrong direction flush all commands. @multiple */
#define PMSRE_CTRL_ADDR                              0x000000c0
/** Enable motor driver. @multiple */
  #define PMSRE_CTRL_ENABLE_COUNT                  8
  #define PMSRE_CTRL_ENABLE(fidx)                  (0x00000001 << ((fidx)))
/** Enable watching end-stop input in increase direction. @multiple */
  #define PMSRE_CTRL_ISTOP_COUNT                   8
  #define PMSRE_CTRL_ISTOP(fidx)                   (0x00000100 << ((fidx)))
/** Enable watching end-stop input in decrease direction. @multiple */
  #define PMSRE_CTRL_DSTOP_COUNT                   8
  #define PMSRE_CTRL_DSTOP(fidx)                   (0x00010000 << ((fidx)))
/** Raise irq output on fault condition on an enabled motors. @multiple */
  #define PMSRE_CTRL_FIRQ                          0x01000000
/** Raise irq output on completed fifo not empty. @multiple */
  #define PMSRE_CTRL_CIRQ                          0x02000000
/** Clear the position registers when a command ends @multiple */
  #define PMSRE_CTRL_ZERO                          0x80000000

#endif

